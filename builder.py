import sys, os, errno, stat, fcntl
import jwack
from helpers import (
    close_on_exec,
    join,
    possible_do_files,
    relpath,
    try_stat,
    unlink,
    )
from log import log, log_, debug, debug2, debug3, err, warn
from db import FileDBMixin, ALWAYS


STAMP_DIR='dir'     # the stamp of a directory; mtime is unhelpful
STAMP_MISSING='0'   # the stamp of a nonexistent file

CLEAN = 0
DIRTY = 1


class ImmediateReturn(Exception):
    def __init__(self, rv):
        Exception.__init__(self, "immediate return with exit code %d" % rv)
        self.rv = rv


def warn_override(name):
    warn('%s - you modified it; skipping\n' % name)


def _nice(t, base):
    return relpath(t, base)


class BuildJob:
    def __init__(self, bc, sf, lock, shouldbuildfunc, donefunc):
        self.bc = bc
        self.sf = sf
        self.tmpname1, self.tmpname2 = sf.get_tempfilenames()
        self.lock = lock
        self.shouldbuildfunc = shouldbuildfunc
        self.donefunc = donefunc
        self.before_t = sf.try_stat()

    def _nice(self, t):
        return relpath(t, self.bc.STARTDIR)

    def start(self):
        assert self.lock.owned
        try:
            dirty = self.shouldbuildfunc(self.sf.t)
            if not dirty:
                # target doesn't need to be built; skip the whole task
                return self._report_results_and_unlock(0)
        except ImmediateReturn, e:
            return self._report_results_and_unlock(e.rv)

        if self.bc.NO_OOB or isinstance(dirty, (bool, int)) and dirty:
            self._start_do()
        else:
            self._start_unlocked(dirty)

    def _start_do(self):
        assert self.lock.owned
        t = self.sf.t
        sf = self.sf

        if sf.check_externally_modified():
            warn_override(self._nice(t))
            sf.set_externally_modified()
            return self._report_results_and_unlock(0)

        if sf.existing_not_generated():
            # an existing source file that was not generated by us.
            # This step is mentioned by djb in his notes.
            # For example, a rule called default.c.do could be used to try
            # to produce hello.c, but we don't want that to happen if
            # hello.c was created by the end user.
            # FIXME: always refuse to redo any file that was modified outside
            # of redo?  That would make it easy for someone to override a
            # file temporarily, and could be undone by deleting the file.
            debug2("-- static (%r)\n" % t)
            sf.set_something_else()
            return self._report_results_and_unlock(0)

        (dodir, dofile, basedir, basename, ext) = sf.find_do_file()
        if not dofile:
            if os.path.exists(t):
                sf.set_something_else()
                return self._report_results_and_unlock(0)
            else:
                err('no rule to make %r\n' % t)
                return self._report_results_and_unlock(1)
                
        self.argv = self._setup_argv(dodir, dofile, basename, ext)
        log('%s\n' % self._nice(t))
        self.dodir = dodir
        self.basename = basename
        self.ext = ext
        sf.is_generated = True
        sf.save()
        dof = File(self.bc, name=os.path.join(dodir, dofile))
        dof.set_static()
        dof.save()
        self.bc.commit()
        jwack.start_job(t, self._do_subproc, self._after)

    def _start_unlocked(self, dirty):
        # out-of-band redo of some sub-objects.  This happens when we're not
        # quite sure if t needs to be built or not (because some children
        # look dirty, but might turn out to be clean thanks to checksums). 
        # We have to call redo-unlocked to figure it all out.
        #
        # Note: redo-unlocked will handle all the updating of sf, so we
        # don't have to do it here, nor call _check_results.  However, we have to
        # hold onto the lock because otherwise we would introduce a race
        # condition; that's why it's called redo-unlocked, because it doesn't
        # grab a lock.
        argv = ['redo-unlocked', self.sf.name] + [d.name for d in dirty]
        log('(%s)\n' % self._nice(self.sf.t))
        self.bc.commit()
        def run():
            os.chdir(self.bc.BASE)
            self.bc.incr_DEPTH()
            os.execvp(argv[0], argv)
            assert 0
            # returns only if there's an exception
        def after(t, rv):
            return self._report_results_and_unlock(rv)
        jwack.start_job(self.sf.t, run, after)

    def _setup_argv(self, dodir, dofile, basename, ext):
        unlink(self.tmpname1)
        unlink(self.tmpname2)

        ffd = os.open(self.tmpname1, os.O_CREAT|os.O_RDWR|os.O_EXCL, 0666)
        close_on_exec(ffd, True)
        self.f = os.fdopen(ffd, 'w+')

        # this will run in the dofile's directory, so use only basenames here
        if self.bc.OLD_ARGS:
            arg1 = basename  # target name (no extension)
            arg2 = ext       # extension (if any), including leading dot
        else:
            arg1 = basename + ext  # target name (including extension)
            arg2 = basename        # target name (without extension)

        argv = ['sh', '-e',
                dofile,
                arg1,
                arg2,
                # temp output file name
                relpath(os.path.abspath(self.tmpname2), dodir),
                ]

        if self.bc.VERBOSE:
            argv[1] += 'v'
        if self.bc.XTRACE:
            argv[1] += 'x'
        if self.bc.VERBOSE or self.bc.XTRACE:
            log_('\n')

        firstline = open(os.path.join(dodir, dofile)).readline().strip()
        if firstline.startswith('#!/'):
            argv[0:2] = firstline[2:].split(' ')

        return argv

    def _do_subproc(self):
        # careful: REDO_PWD was the PWD relative to the STARTPATH at the time
        # we *started* building the current target; but that target ran
        # redo-ifchange, and it might have done it from a different directory
        # than we started it in.  So os.getcwd() might be != REDO_PWD right
        # now.
        dn = self.dodir
        self.bc.set_subprocess_context(dn, self.basename + self.ext)
        self.bc.incr_DEPTH()
        if dn:
            os.chdir(dn)
        os.dup2(self.f.fileno(), 1)
        os.close(self.f.fileno())
        close_on_exec(1, False)
        if self.bc.VERBOSE or self.bc.XTRACE:
            log_('* %s\n' % ' '.join(self.argv))
        os.execvp(self.argv[0], self.argv)
        assert 0
        # returns only if there's an exception

    def _after(self, t, rv):
        assert t == self.sf.t
        try:
            self.bc.check_sane()
            rv = self._check_results(t, rv)
            self.bc.commit()
        finally:
            self._report_results_and_unlock(rv)

    def _check_results(self, t, rv):
        rv = self._check_direct_modify(rv)
        if rv:
            self._nah(rv)
            return rv

        f = self.f
        st1 = os.fstat(f.fileno())
        st2 = try_stat(self.tmpname2)

        rv = self._check_redundant_output(st1, st2, rv)
        if rv:
            self._nah(rv)
            return rv

        assert rv == 0
        self._yeah(st1, st2)
        self.sf.fin()
        f.close()

        if self.bc.VERBOSE or self.bc.XTRACE or self.bc.DEBUG:
            log('%s (done)\n\n' % self._nice(t))
        return rv

    def _report_results_and_unlock(self, rv):
        try:
            self.donefunc(self.sf.t, rv)
            assert self.lock.owned
        finally:
            self.lock.unlock()

    def _check_direct_modify(self, rv):
        before_t = self.before_t
        after_t = self.sf.try_stat()
        if (after_t and
            (not before_t or before_t.st_ctime != after_t.st_ctime) and
            not stat.S_ISDIR(after_t.st_mode)):
            err('%s modified %s directly!\n' % (self.argv[2], self.sf.t))
            err('...you should update $3 (a temp file) or stdout, not $1.\n')
            return 206
        return rv

    def _check_redundant_output(self, st1, st2, rv):
        if st2 and st1.st_size > 0:
            err('%s wrote to stdout *and* created $3.\n' % self.argv[2])
            err('...you should write status messages to stderr, not stdout.\n')
            return 207
        return rv

    def _nah(self, rv):
        unlink(self.tmpname1)
        unlink(self.tmpname2)
        self.sf.set_failed()
        self.f.close()
        err('%s: exit code %d\n' % (self._nice(self.sf.t), rv))

    def _yeah(self, st1, st2):
        t = self.sf.t
        if st2:
            os.rename(self.tmpname2, t)
            os.unlink(self.tmpname1)
        elif st1.st_size > 0:
            try:
                os.rename(self.tmpname1, t)
            except OSError, e:
                if e.errno == errno.ENOENT:
                    unlink(t)
                else:
                    raise
            if st2:
                os.unlink(self.tmpname2)
        else: # no output generated at all; that's ok
            unlink(self.tmpname1)
            unlink(t)


class File(FileDBMixin, object):

    def __init__(self, bc, id_=None, name=None, cols=None):
        self.bc = bc
        FileDBMixin.__init__(self, id_, name, cols)

# Stuff that doesn't use the db directly

    def should_build(self, runid):
        if self.is_failed():
            raise ImmediateReturn(32)
        dirty = self.is_dirty(max_changed=runid)
        if dirty == [self]:
            return DIRTY
        return dirty

    def set_checked(self):
        self.checked_runid = self.bc.RUNID

    def set_changed(self):
        debug2('BUILT: %r (%r)\n' % (self.name, self.stamp))
        self.changed_runid = self.bc.RUNID
        self.failed_runid = None
        self.is_override = False

    def set_failed(self):
        debug2('FAILED: %r\n' % self.name)
        self._update_stamp()
        self.failed_runid = self.bc.RUNID
        self.is_generated = True
        self._zap_deps2()
        self.save()

    def set_static(self):
        self._update_stamp(must_exist=True)
        self.is_override = False
        self.is_generated = False

    def set_csum(self, csum):
        changed = (csum != self.csum)
        debug2('%s: old = %s\n' % (self.name, self.csum))
        debug2('%s: sum = %s (%s)\n' % (self.name, csum,
                                        ('unchanged', 'changed')[changed]))
        self.is_generated = True
        self.is_override = False
        self.failed_runid = None
        if changed:
            self.set_changed() # update_stamp might not do this
                               # if the mtime is identical
            self.csum = csum
        else:
            # unchanged
            self.set_checked()

    def is_failed(self):
        return self.failed_runid and self.failed_runid >= self.bc.RUNID

    def stamp_not_missing(self):
        return self._read_stamp() != STAMP_MISSING

    def nicename(self):
        return relpath(os.path.join(self.bc.BASE, self.name), self.bc.STARTDIR)

    def special(self):
        return self.name.startswith('//')

    def get_tempfilenames(self):
        tmpbase = self.t
        while not os.path.isdir(os.path.dirname(tmpbase) or '.'):
            ofs = tmpbase.rfind('/')
            assert ofs >= 0
            tmpbase = tmpbase[:ofs] + '__' + tmpbase[ofs + 1:]
        return ('%s.redo1.tmp' % tmpbase), ('%s.redo2.tmp' % tmpbase)

    def try_stat(self):
        return try_stat(self.t)

    def check_externally_modified(self):
        newstamp = self._read_stamp()
        return (self.is_generated and
                newstamp != STAMP_MISSING and
                (self.stamp != newstamp or self.is_override))

    def set_externally_modified(self):
        self._set_override()
        self.set_checked()
        self.save()

    def existing_not_generated(self):
        return (os.path.exists(self.t) and
                not os.path.isdir(self.t + '/.') and
                not self.is_generated)

    def set_something_else(self):
        self.set_static()
        self.save()

    def find_do_file(self):
        self._zap_deps1()
        for dodir, dofile, basedir, basename, ext in possible_do_files(self.name, self.bc.BASE):
            dopath = os.path.join(dodir, dofile)
            debug2('%s: %s:%s ?\n' % (self.name, dodir, dofile))
            if os.path.exists(dopath):
                self.add_dep('m', dopath)
                return dodir, dofile, basedir, basename, ext
            self.add_dep('c', dopath)
        return None, None, None, None, None

    def is_dirty(self, max_changed, depth='',
                 is_checked=None, set_checked=None):
        is_checked = is_checked or File._is_checked
        set_checked = set_checked or File._set_checked_save
        if self.bc.DEBUG >= 1:
            debug('%s?%s\n' % (depth, self.nicename()))

        if self.failed_runid:
            debug('%s-- DIRTY (failed last time)\n' % depth)
            return DIRTY
        if self.changed_runid is None:
            debug('%s-- DIRTY (never built)\n' % depth)
            return DIRTY
        if self.changed_runid > max_changed:
            debug('%s-- DIRTY (built)\n' % depth)
            return DIRTY  # has been built more recently than parent
        if is_checked(self):
            if self.bc.DEBUG >= 1:
                debug('%s-- CLEAN (checked)\n' % depth)
            return CLEAN  # has already been checked during this session
        if not self.stamp:
            debug('%s-- DIRTY (no stamp)\n' % depth)
            return DIRTY

        newstamp = self._read_stamp()
        if self.stamp != newstamp:
            if newstamp == STAMP_MISSING:
                debug('%s-- DIRTY (missing)\n' % depth)
            else:
                debug('%s-- DIRTY (mtime)\n' % depth)
            if self.csum:
                return [self]
            else:
                return DIRTY

        must_build = []
        for mode, f2 in self._deps():
            assert mode in ('c', 'm')
            dirty = CLEAN
            if mode == 'c':
                if os.path.exists(os.path.join(self.bc.BASE, f2.name)):
                    debug('%s-- DIRTY (created)\n' % depth)
                    dirty = DIRTY
            elif mode == 'm':
                sub = f2.is_dirty(max(self.changed_runid, self.checked_runid),
                                 depth=depth + '  ',
                                 is_checked=is_checked, set_checked=set_checked)
                if sub:
                    debug('%s-- DIRTY (sub)\n' % depth)
                    dirty = sub

            if not self.csum:
                # self is a "normal" target:
                # dirty f2 means self is instantly dirty
                if dirty:
                    # if dirty==DIRTY, this means self is definitely dirty.
                    # if dirty==[...], it's a list of the uncertain children.
                    return dirty
            else:
                # self is "checksummable": dirty f2 means self needs to redo,
                # but self might turn out to be clean after that (ie. our
                # parent might not be dirty).
                if dirty == DIRTY:
                    # f2 is definitely dirty, so self definitely needs to
                    # redo.  However, after that, self might turn out to be
                    # unchanged.
                    return [self]

                elif isinstance(dirty, list):
                    # our child f2 might be dirty, but it's not sure yet.  It's
                    # given us a list of targets we have to redo in order to
                    # be sure.
                    must_build.extend(dirty)

        if must_build:
            # self is *maybe* dirty because at least one of its children is
            # maybe dirty.  must_build has accumulated a list of "topmost"
            # uncertain objects in the tree.  If we build all those, we can then
            # redo-ifchange self and it won't have any uncertainty next time.
            return must_build

        # if we get here, it's because the target is clean
        if self.is_override:
            warn_override(self.name)
        set_checked(self)
        return CLEAN

    def fin(self):
        self._refresh()
        self.is_generated = True
        self.is_override = False
        if self._is_checked() or self._is_changed():
            # it got checked during the run; someone ran redo-stamp.
            # _update_stamp would call set_changed(); we don't want that
            self.stamp = self._read_stamp()
        else:
            self.csum = None
            self._update_stamp()
            self.set_changed()
        self._zap_deps2()
        self.save()

    def _refresh(self):
        self._init_from_idname(self.id, None)

    def _set_checked_save(self):
        self.set_checked()
        self.save()

    def _set_override(self):
        self._update_stamp()
        self.is_override = True

    def _update_stamp(self, must_exist=False):
        newstamp = self._read_stamp()
        if must_exist and newstamp == STAMP_MISSING:
            raise Exception("%r does not exist" % self.name)
        if newstamp != self.stamp:
            debug2("STAMP: %s: %r -> %r\n" % (self.name, self.stamp, newstamp))
            self.stamp = newstamp
            self.set_changed()

    def _is_checked(self):
        return self.checked_runid and self.checked_runid >= self.bc.RUNID

    def _is_changed(self):
        return self.changed_runid and self.changed_runid >= self.bc.RUNID

    def _read_stamp(self):
        try:
            st = os.stat(os.path.join(self.bc.BASE, self.name))
        except OSError:
            return STAMP_MISSING
        if stat.S_ISDIR(st.st_mode):
            return STAMP_DIR
        else:
            # a "unique identifier" stamp for a regular file
            return str((st.st_ctime, st.st_mtime, st.st_size, st.st_ino))


# FIXME: I really want to use fcntl F_SETLK, F_SETLKW, etc here.  But python
# doesn't do the lockdata structure in a portable way, so we have to use
# fcntl.lockf() instead.  Usually this is just a wrapper for fcntl, so it's
# ok, but it doesn't have F_GETLK, so we can't report which pid owns the lock.
# The makes debugging a bit harder.  When we someday port to C, we can do that.
_locks = {}
class Lock:
    def __init__(self, bc, fid):
        self.owned = False
        self.fid = fid
        self.lockfile = os.open(os.path.join(bc.BASE, '.redo/lock.%d' % fid),
                                os.O_RDWR | os.O_CREAT, 0666)
        close_on_exec(self.lockfile, True)
        assert _locks.get(fid, 0) == 0
        _locks[fid] = 1

    def __del__(self):
        _locks[self.fid] = 0
        if self.owned:
            self.unlock()
        os.close(self.lockfile)

    def trylock(self):
        assert not self.owned
        try:
            fcntl.lockf(self.lockfile, fcntl.LOCK_EX|fcntl.LOCK_NB, 0, 0)
        except IOError, e:
            if e.errno in (errno.EAGAIN, errno.EACCES):
                pass  # someone else has it locked
            else:
                raise
        else:
            self.owned = True

    def waitlock(self):
        assert not self.owned
        fcntl.lockf(self.lockfile, fcntl.LOCK_EX, 0, 0)
        self.owned = True

    def unlock(self):
        if not self.owned:
            raise Exception("can't unlock %r - we don't own it" 
                            % self.lockname)
        fcntl.lockf(self.lockfile, fcntl.LOCK_UN, 0, 0)
        self.owned = False


def main(bc, targets, shouldbuildfunc):
    retcode = [0]  # a list so that it can be reassigned from done()
    if bc.SHUFFLE:
        import random
        random.shuffle(targets)

    locked = []

    def done(t, rv):
        if rv:
            retcode[0] = 1

    # In the first cycle, we just build as much as we can without worrying
    # about any lock contention.  If someone else has it locked, we move on.
    seen = {}
    lock = None
    for t in targets:
        if t in seen:
            continue
        seen[t] = 1
        if not jwack.has_token():
            bc.commit()
        jwack.get_token(t)
        if retcode[0] and not bc.KEEP_GOING:
            break
        if not bc.check_sane():
            err('.redo directory disappeared; cannot continue.\n')
            retcode[0] = 205
            break
        f = bc.file_from_name(t)
        lock = Lock(bc, f.id)
        if bc.UNLOCKED:
            lock.owned = True
        else:
            lock.trylock()
        if not lock.owned:
            if bc.DEBUG_LOCKS:
                log('%s (locked...)\n' % _nice(t, bc.BASE))
            locked.append((f.id,t))
        else:
            BuildJob(bc, f, lock, shouldbuildfunc, done).start()

    del lock

    # Now we've built all the "easy" ones.  Go back and just wait on the
    # remaining ones one by one.  There's no reason to do it any more
    # efficiently, because if these targets were previously locked, that
    # means someone else was building them; thus, we probably won't need to
    # do anything.  The only exception is if we're invoked as redo instead
    # of redo-ifchange; then we have to redo it even if someone else already
    # did.  But that should be rare.
    while locked or jwack.running():
        bc.commit()
        jwack.wait_all()
        # at this point, we don't have any children holding any tokens, so
        # it's okay to block below.
        if retcode[0] and not bc.KEEP_GOING:
            break
        if locked:
            if not bc.check_sane():
                err('.redo directory disappeared; cannot continue.\n')
                retcode[0] = 205
                break
            fid,t = locked.pop(0)
            lock = Lock(bc, fid)
            lock.trylock()
            while not lock.owned:
                if bc.DEBUG_LOCKS:
                    warn('%s (WAITING)\n' % _nice(t, bc.BASE))
                # this sequence looks a little silly, but the idea is to
                # give up our personal token while we wait for the lock to
                # be released; but we should never run get_token() while
                # holding a lock, or we could cause deadlocks.
                jwack.release_mine()
                lock.waitlock()
                lock.unlock()
                jwack.get_token(t)
                lock.trylock()
            assert lock.owned
            if bc.DEBUG_LOCKS:
                log('%s (...unlocked!)\n' % _nice(t, bc.BASE))
            if bc.file_from_name(t).is_failed():
                err('%s: failed in another thread\n' % _nice(t, bc.BASE))
                retcode[0] = 2
                lock.unlock()
            else:
                BuildJob(bc, bc.file_from_id(fid), lock,
                         shouldbuildfunc, done).start()
    bc.commit()
    return retcode[0]

